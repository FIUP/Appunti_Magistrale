<html><head><meta charset="utf-8"><link rel="stylesheet" href="_builder/pdf.css"><link rel="stylesheet" href="_builder/highlight/styles/default.css"><script src="_builder/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><h1 id="sistemi-con-vincoli">Sistemi con vincoli</h1>
<h2 id="introduzione">Introduzione</h2>
<p>Programmazione a vincoli: constraint programmmig</p>
<p><strong>CSP</strong> --&gt; <strong>C</strong>onstraint <strong>S</strong>atisfaction <strong>P</strong>roblem</p>
<p><strong>COP</strong> --&gt; <strong>C</strong>onstraint <strong>O</strong>ptimization <strong>P</strong>roblem: problema di ottimizazione con vincoli, è diverso dalla programmazione lineare.</p>
<p>Appartengono a questa tipologia di problemi i tipici problemi gestionali, come la pianificazione dell&#39;orario dei treni o la gestione dei porti.</p>
<p>La risoluzione di uno di questi problemi si basa sempre sulla costruzione di un modello, in modo analogo alla Programmazione Lineare, solo che nella modellazione non venogno utilizzate le equazioni lineari.</p>
<h2 id="problemi-combinatori-csp">Problemi combinatori - CSP</h2>
<p>Sono una tipologia di problemi come la colorazione di una cartina utilizzando <em>n</em> colori o la risoluzione di un sudoko.</p>
<p>Questi hanno un pattern simile di risoluzione:</p>
<ul>
<li>Si cercano dei vincoli per limitare le possibili mosse</li>
<li>Si fanno determinate scelte e se sono sbagliate si torna indietro</li>
</ul>
<p>Su un foglio di carta è più semplice da fare, in CP si cerca di formalizzare queste cose per un computer.</p>
<blockquote>
<p>CSP = \&lt;X,D,C\&gt;</p>
<ul>
<li>X: insieme di variabili, con x<sub>i</sub> si indica una variabile dell&#39;insieme;</li>
<li>D: insieme di domini, x<sub>i</sub> ha dominio D(x<sub>i</sub>);</li>
<li>C: insieme di vincoli, c<sub>j</sub> è definito su un sottoinsieme di varibili, X(c<sub>j</sub>) e viene detto <em>ambito del vincolo</em> (scope in inglese).</li>
</ul>
</blockquote>
<p><strong>Tupla</strong>: sequenza fissata di valori.</p>
<p><strong>Relazione</strong>: Data <em>S</em> sequenza di insiemi = S<sub>0</sub>, S<sub>1</sub>, S<sub>2</sub>, ecc.
Una relazione <em>R</em> su <em>S</em> è un sottoinsieme del prodotto cartesiano della sequenza <em>S</em>.</p>
<p>Un vincolo è quindi una sorta di tabella con tutti i possibili valori validi (<strong>feasible</strong>) per le relazione definite tra i vari domini delle variabili del problema.</p>
<p>Una soluzione per un CPS è quindi tupla definita sul prodotto cartesiano di tutti i domini che è consistente con tutti i vincoli. (Una soluzione è quindi una relazione sull&#39;insieme dei domini).</p>
<p>Un CSP senza soluzione si dice <strong>infisable</strong>, senza soluzione.</p>
<p>Un CSP può essere definito con ogni tipo di dominio e vincolo</p>
<p>Tipicamente come domini vengono utilizzati:</p>
<ul>
<li>Interi</li>
<li>Reali</li>
<li>Set</li>
<li>Grafi</li>
</ul>
<p>Nel corso noi useremo domini interi finiti (finite domains), con i quali è possibile utilizzare qualsiasi tipo di vincolo, rappresentandolo in forma estensionale, cioè andando ad enumerare tutti i possibili assegnamenti di variabili che lo soddisfano.
Questa modellazione dei vincoli però è scomoda e inefficente, e tipicamnete viene utilizzata la forma &quot;<em>intensional</em>&quot;</p>
<p>Per esprimere dei vincoli con questa forma vengono utilizzate delle Constraint libraries,  delle collezioni di tipologie di vincoli come:</p>
<ul>
<li><strong>equality</strong>: x==y</li>
<li><strong>disequality</strong>: x!=y</li>
</ul>
<p>Ad esempio, utilizzando queste due tipologie di vincoli è possibile andare a modellare il problema della colorazione della cartina del nord italia con:</p>
<ul>
<li>variabili: x<sub>i</sub> ϵ {0..3} per ogni regione;</li>
<li>vincoli: x<sub>i</sub> != x<sub>j</sub> per le regioni confinanti.</li>
</ul>
<h2 id="filtering">Filtering</h2>
<p>L&#39;idea è che alcuni valori per determinate variabili non potranno mai essere usati in una soluzione, questo perché eseguendo uno di questi assegnamenti alcuni vincoli vengono violati. </p>
<p>Si può quindi andare a filtrare per un determinato vincolo, cioè rimuovere dai domini delle variabili alcuni valori che sono sicuramente non soddisfacibili.
Questo processo prende il nome di <strong>filtering</strong>, mentre l&#39;atto di rimuovere un valore viene detto <strong>pruning</strong>.</p>
<p>Il filtering fatto da un vincolo può permettere ad un altro vincolo di fare ulteriore filtering, in questo caso si dice che fa <strong>propagation</strong>.</p>
<p>La propagazione viene effettuata mediante un algoritmo.</p>
<h3 id="ac1-il-primo-algoritmo-di-propagazione">AC1: il primo algoritmo di propagazione</h3>
<pre><code class="lang-python">dirty = <span class="hljs-literal">true</span>
white <span class="hljs-string">dirty:</span>
    dirty = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">for</span> cj <span class="hljs-keyword">in</span> <span class="hljs-string">C:</span>
        dirty = dirty or cj.filter()
</code></pre>
<p>Assumendo che <code>cj.filter()</code> ritorni <code>true</code> se il filtering ha tagliato dei valori.</p>
<p>AC1 raggiunge sempre un punto fisso che non dipende dall&#39;ordine in cui sono stati processati i vincoli.</p>
<p>Ciò si dimostra introducendo la funzione <em>filtered<sub>c</sub>(D)</em> che applica l&#39;algoritmo di filtering per il vincolo <em>c</em> nel dominio <em>D</em> e ritorna il dominio filtrato.
Dal momento che questa può solo togliere dei valori è ovvio che dopo un numero finito di passi la funzione non sarà più in grado di rimuovere valori, raggiungendo così un punto fisso, che nel caso pessimo è dato dall&#39;insieme vuoto.</p>
<p>La funzione <em>filtered<sub>c</sub>(D)</em> è anche monotona, filtrare un dominio di partenza già filtrato, può solo produrre un insieme ulteriormente filtrato.</p>
<p>Tutto questo prende il nome di <strong>Fix Point Theorem</strong>.</p>
<p>Una conseguenza di questo teorema è che l&#39;ordine secondo il quale viene effettuato il filtering non influisce sul risultato. Tuttavia l&#39;ordine con cui eseguo il filtering influisce sul numero di iterazioni necessarie e determinare l&#39;ordine migliore è un problema NP-difficile.</p>
<h2 id="solving-ricerca-delle-soluzioni-">Solving (Ricerca delle soluzioni)</h2>
<p>Dopo aver filtrato e propagato non sempre si ottiene una soluzione, in questo caso è necessario andare a tentativi, cioè scegliere una variabile ed assegnarle uno dei possibili valori.</p>
<h3 id="depth-first-search">Depth First Search</h3>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span><span class="hljs-params">(CSP)</span>:</span>
    <span class="hljs-keyword">if</span> sol_found: <span class="hljs-keyword">return</span> true
    <span class="hljs-keyword">if</span> infeasible: <span class="hljs-keyword">return</span> false
    <span class="hljs-keyword">for</span> dec <span class="hljs-keyword">in</span> decisions(CSP):
        <span class="hljs-keyword">if</span> DFS(apply(dec, CSP)): <span class="hljs-keyword">return</span> true
    <span class="hljs-keyword">return</span> false
</code></pre>
<p>L&#39;algortimo fa <em>backtracking</em>, cioè se non raggiunge una soluzione, distrugge il ramo decisionale che ha seguito e ne inizia un&#39;altro.</p>
<p>Per determinare che un problema è infiseable bisogna valutare i domini delle variabili, se uno di questi è vuoto allora il problema non ha soluzione (<strong>domain wipeout</strong>).</p>
<p>La funzione <code>decision(CSP)</code> usa l&#39;insieme dei vincoli per scegliere un valore per una variabile <em>unbound</em>, cioè una variabile alla quale non è ancora stato assegnato un valore e il cui dominio contiene più valori.</p>
<p>Una possibile decisione può essere quella di selezionare il valore minore presente nel dominio di una variabile e provare ad eseguire l&#39;assegnazione, creando così un ramo decisionale. Viene poi creato un altro ramo nel quale la variabile viene posta diversa dal valore scelto.</p>
<p>Dopodichè si prosegue l&#39;esplorazione dell&#39;albero lungo il primo ramo decisionale e se si arriva ad una soluzione infeasibile viene effettauto il backtracking.</p>
<p>Dopo aver preso una decisione, questa viene propagata utilizzando AC1, restringendo ulteriormente l&#39;ambito delle possibili scelte.</p>
<h1 id="lezione-2-alcune-generalizzazioni">Lezione 2 - Alcune generalizzazioni</h1>
<p>La risoluzione di un problema di CP può essere vista in 3 fasi:</p>
<ul>
<li>Creazione di un modello utilizzando una libreria di vincoli;</li>
<li>Ricerca di una soluzione;</li>
<li>Restrizione dello spazio di ricerca tramite filtering e propagation.</li>
</ul>
<h2 id="restrizione-di-domini">Restrizione di domini</h2>
<p>Restringendo lo spazio di ricerca a partire da un&#39;insieme di domini <em>D<sub>0</sub>,D<sub>1</sub>,...</em> si arriva ad un altro un&#39;insieme <em>D<sub>0</sub>&#39;,D<sub>1</sub>&#39;...</em> tale che <em>D<sub>0</sub>&#39; ⊆ D<sub>0</sub>,...</em></p>
<p>Questo può essere visto come una generalizzazione dell&#39;operazione di assegnamento, che cattura l&#39;effetto del filtering e della ricerca.</p>
<h2 id="vincolo-risolto">Vincolo risolto</h2>
<p>Un vincolo si dice <strong>risolto</strong> se coincide con il prodotto cartesiano nel suo scope.</p>
<p>Cioè effettuando il prodotto cartesiano dei domini di tutte le variabili presenti nel vincolo, questo prodotto contiente solo relazioni che soddisfano il vincolo, generalizzando così la definizione di <strong>feasibility</strong> di un assegnamento.</p>
<h2 id="soluzione-csp">Soluzione CSP</h2>
<p>È una restrizione di tutti i domini tale che tutti i vincoli siano risolti, cioè ogni possibile assegnamento di tutte le variabili soddisfa tutti i vincoli del problema.</p>
<blockquote>
<p>D′(x<sub>i</sub>) ∀x<sub>i</sub>∈X : ∀c<sub>j</sub>∈C, c<sub>j</sub>=∏x<sub>i</sub>∈X(c<sub>j</sub>)D′(x<sub>i</sub>)</p>
</blockquote>
<p>Una caso particolare di questa generalizzazione è quandp tutti i domini di tutte le variabili sono dei singoletti, cioè sono composti da un solo elemento.</p>
<h2 id="dfs-depth-first-search">DFS - Depth first search</h2>
<p>Utilizzando questi concetti di generalizzazione è possibile andare a migliorare gli algoritmi di ricerca e filtering.</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span><span class="hljs-params">(CSP)</span>:</span>
  <span class="hljs-keyword">if</span> gen_sol_found(CSP): <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
  <span class="hljs-keyword">if</span> infeasible(CSP): <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
  <span class="hljs-keyword">for</span> dec <span class="hljs-keyword">in</span> decisions(CSP):
    <span class="hljs-keyword">if</span> DFS(apply(dec, CSP)): <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre>
<p>L&#39;algoritmo di ricerca base può essere ottimizzato facendolo terminare quando viene trovata una soluzione generalizzata.</p>
<p>Allo stesso modo può essere modificato <strong>AC1</strong> in modo che se un vincolo è già risolto, allora non venga eseguito il filtering per tale vincolo.</p>
<pre><code class="lang-python">dirty = True
while dirty:
  dirty = False
  <span class="hljs-keyword">for</span> cj <span class="hljs-keyword">in</span> C:
    <span class="hljs-keyword">if</span> not <span class="hljs-function"><span class="hljs-title">resolved</span><span class="hljs-params">(cj, CSP)</span></span>:
      dirty = dirty or cj.<span class="hljs-function"><span class="hljs-title">filter</span><span class="hljs-params">()</span></span>
</code></pre>
<p>Per effettuare queste ottimizzazioni è necessario poter determinare se il vincolo è risolto o meno e non sempre questo è possibile.</p>
<p>Da notare che, nel caso si ottengano dei domini singoletti dopo aver filtrato per un vincolo, non è più conveniente eseguire altro filtering con quel vincolo, dal momento che più di così non si può fare.</p>
<h2 id="vincoli-aritmetici-e-espressioni">Vincoli aritmetici e espressioni</h2>
<p><strong>N-Queens</strong>: si vogliono disporre su una schacchiera <em>NxN</em>, <em>N</em> regine in modo che non si minaccino tra loro.</p>
<p>Per modellare questo problema è necessario focalizzarsi sulle decisioni da prendere e come conviene codificare tali decisioni.</p>
<p>Ad esempio come modello per questo problema si può usare una variabile per ogni colonna che specifica in quale riga della scacchiera è presente la regina.</p>
<p>In questo modo si ottiene un dominio per le variabili già ridotto e più compatto rispetto al modello che ha tante variabili quante sono le caselle della scacchiera.</p>
<p>Con questa modellazione i vincoli del problema diventano:</p>
<ul>
<li>Non possono esserci due regine sulla stessa colonna --&gt; sempre soddisfatto per come sono definite le variabili.</li>
<li>Non possono esserci due regine sulla stessa riga --&gt; <em>x<sub>i</sub> ≠ x<sub>j</sub></em> per ogni <em>i</em> e <em>j</em>, cioè due variabili non possono avere lo stesso valore e per come è espresso il problema vuol dire che due colonne diverse non possono essere avere la regina sulla stessa riga.</li>
<li>Non possono esserci due regine sulla stessa diagonale --&gt; <em>x<sub>j</sub> - x<sub>i</sub> ≠ j - i</em>, per ogni coppia <em>i &lt; j</em>, è necessario esprimere anche questo vincolo per l&#39;altra diagonale.</li>
</ul>
<p><strong>Problema</strong>: non sappiamo come modellare <em>x<sub>j</sub> - x<sub>i</sub> ≠ v</em> e non può essere utilizzato un vincolo ad hoc perché si avrebbe un numero di vincoli che aumenta esponenzialmente.</p>
<p>Lo stesso vincolo può essere implementato con <em>x + y = z</em> e <em>z ≠ v</em>, in questo modo definisco due vincoli elementari che possono essere combinati tra loro per creare vincoli più complessi.</p>
<p>Fortunatamente ci sono dei linguaggi di modellazione che eseguono il parsing automatico delle espressioni, permettendo di scrivere espressioni complesse senza preoccuparsi di definire i vincoli più semplici.</p>
<p>Queste espressioni possono essere aggiunte ad una libreria di vincoli come:</p>
<ul>
<li><code>z=x+y</code> sum constraint</li>
<li><code>z=xy</code> multiplication constraint</li>
<li><code>z=|x|</code> absolute value constraint</li>
<li><code>z=min(x,y)</code> minimum constraint</li>
</ul>
<p>dove:</p>
<ul>
<li><code>z</code> viene introdotta in automatico durante il parsing dell&#39;espressione;</li>
<li><code>z</code> è una variabile o un&#39;espressione (concettualmente vengono trattate allo stesso modo, anche se vengono implementate in modo diverso).</li>
<li><code>x</code> e <code>y</code> possono essere variabili, costanti o altre espressioni.</li>
</ul>
<p>Per poter utilizzare in modo efficente questi vincoli è andare a definire delle strategie per fare filtering.</p>
<h2 id="consistenze-locali">Consistenze locali</h2>
<p>L&#39;approccio di scrivere un nuovo algoritmo di filtering per ogni vincolo non scala, è necessario usare un approccio sistematico a questo problema.</p>
<h3 id="vincoli-binari">Vincoli binari</h3>
<p>Si rimouve un valore <em>v</em> dal dominio <em>D(X)</em> se non supporta un determinato vincolo quando viene combinato con i valori del dominio <em>D(Y)</em>.</p>
<p>Un valore <em>v</em> in <em>D(X)</em> si dice che ha un <strong>supporto</strong> se esiste un valore <em>w</em> in <em>D(Y)</em> tale che <em>(v,w)</em> soddisfa un vincolo.</p>
<p>Quando tutti i valori presenti nel dominio hanno un supporto si dice che il vincolo <em>c</em> è consistente sugli archi (<strong>Arc Consistency</strong>).</p>
<p>Viene usato il termine arco in quanto un CSP può essere visto come un grafo i cui nodi sono dati dalle variabili del problema.</p>
<p>La consistenza sugli archi garantisce che vincolo per vincolo ogni assegnamento delle variabili porta ad una soluzione feasible e permette di formalizzare gli algoritmi di filtering.</p>
<p>Questa strategia funziona bene a livello locale, ma a livello globale no, in quanto la conistenza dei vincoli viene forzata vincolo per vincolo, senza tenere conto degli altri vincoli e quindi non è detto che il problema sia globalmente consistente.</p>
<p>Avere consistenza globale è complesso quanto risolvere il problema e dal momento che la complessità dell&#39;algoritmo di filtering risulta particolarmente critica dal momento che deve essere eseguito pià volte per ogni nodo, si preferisce forzare la consistenza locale che è meno complessa.</p>
<p>Ad esempio filtrare per la disuguaglianza di due valori viene fatto in tempo costante, mentre per l&#39;uguaglianza è necessario un tempo lineare.</p>
<h3 id="vincoli-generici">Vincoli generici</h3>
<p><strong>Generalizzazione di supporto</strong>: un valore di un certo dominio è supportato se per tutte le altre variabili nello scope del vincolo esiste un altro valore tale che l&#39;insieme dei valori riesce a soddisfare il vincolo.</p>
<p><strong>Generalizzazione dell&#39;Arc Consinstency</strong>: 
Un vincolo <em>c</em> è consistente sugli archi in modo generalizzato se <em>∀x<sub>i</sub> ∈ X(c)</em> è possibile trovare un valore <em>v ∈ D(x<sub>i</sub>)</em> che ha supporto.</p>
<p>Fare filtering per il vincola della somma ha una complessita cubica, tuttavia con un po&#39; di ottimizzazioni si riesce ad ottenere una complessità quadratica, questo perché nel nostro sistema fare il look-up di un valore ha complessità costante).</p>
<blockquote>
<p>z=x+y</p>
</blockquote>
<p>Regole di filtering</p>
<ul>
<li>se <em>v ∈ D(z)</em> e <em>∀w ∈ D(x)</em>, <em>v − w ∉ D(y)</em>, allora tolgo <em>v</em></li>
<li>se <em>w ∈ D(x)</em> e <em>∀v ∈ D(z)</em>, <em>v − w ∉ D(y)</em>, allora tolgo <em>w</em></li>
<li>se <em>u ∈ D(y)</em> e <em>∀v ∈ D(z)</em>, <em>v − u ∉ D(x)</em>, allora tolgo <em>u</em></li>
</ul>
<p>Così facendo la complessità diventa quadratica nella dimensione di <em>D(x)</em> e <em>D(z)</em>, cioè <em>O(|D(x)|*|D(z)|)</em>.</p>
<h3 id="bound-consistency">Bound consistency</h3>
<p>Se i domini sono un intervallo interno e il minimo e massimo dell&#39;intervallo del dominio hanno un supporto, allora anche tutti i valori nel mezzo hanno un supporto.</p>
<p>Si dice che un valore <em>v<sub>i</sub> ∈ D(x<sub>i</sub>)</em> ha supporto con Bound Consistency se e solo se, ∀x<sub>j</sub> ∈ X(c)∖{x<sub>i</sub>}, esiste un valore <em>v<sub>j</sub> ∈ {min(x<sub>j</sub>)..max(x<sub>j</sub>)}</em> tale che <em>(v<sub>0</sub>,v<sub>1</sub>,...,v<sub>m-1</sub>) ∈ c</em></p>
<p>Un vincolo è BC se per ogni variabile del vincolo, sia il minimo che il massimo valore di quella variabile hanno un supporto.</p>
<p>In alcuni casi BC equivale a GAC anche se tipicamente questa tipologia di consistenza è più debole.</p>
<p>In ogni caso, sia la bound consistency che l&#39;arc consistency garantiscono un domani wipeout nel caso non ci siano soluzioni, la differenza riguarda l&#39;efficenza dei due algoritmi: AC è più costoso in termini di tempo ma permette di diminuire il tempo necessario alla ricerca, mentre BC è più veloce da applicare ma taglia meno valori, con un conseguente aumento del tempo necessario alla ricerca.</p>
<h2 id="lezione-3-bound-checking">Lezione 3 - Bound Checking</h2>
<p>Applicando la bound consistency si cambia il problema di filtering, in quanto non si va a controllare il supporto dei valori uno a uno, ma si controllano solamente i valori dei domini, ottentendo un sistema più efficente.
Nonstante ciò bound consistency è più debole di GAC, specialmente nel caso in cui il dominio ha dei buchi, che non vengono considerati da BC.</p>
<h2 id="ac-bc">AC/BC</h2>
<p>Entrambi gli algoritmi di filtering sono incompleti.</p>
<p>AC risulta più efficace il che risulta in un tempo di ricerca minore, tuttavia risulta più costoso fare propagazione.</p>
<p>BC risulta meno efficace e la ricerca rimane costosa, tuttavia è molto veloce da propagare.</p>
<p>Tipicamente la maggior parte dei solver utilizzano BC al posto di AC, questo perché nei problemi reali tipicamente vengono utilizzati domini continui determinati da un intervallo.</p>
<h2 id="bc-per-il-vincolo-della-somma">BC per il vincolo della somma</h2>
<p>Filtering su <em>z</em></p>
<blockquote>
<p>z = x + y</p>
<p>ub = Max(x) + Max(y) --&gt; Max(z) = ub</p>
<p>lb = Min(x) + Min(y) --&gt; Min(z) = lb</p>
</blockquote>
<p>Filtering su <em>x</em> (analogo per <em>y</em>)</p>
<blockquote>
<p>z = x + y</p>
<p>ub = Max(z) - Min(y) --&gt; Max(x) = ub</p>
<p>lb = Min(z) - Max(z) --&gt; Min(x) = lb</p>
</blockquote>
<h2 id="bc-per-il-vincolo-della-moltiplicazione">BC per il vincolo della moltiplicazione</h2>
<p>Filtering su <em>z</em></p>
<blockquote>
<p>z = x * y</p>
<p>ub = Max(Max(x)Max(y),Max(x)Min(y),Min(x)Max(y),Min(x)Min(y))--&gt; Max(z) = ub</p>
<p>lb = Min(Max(x)Max(y),Max(x)Min(y),Min(x)Max(y),Min(x)Min(y))--&gt; Min(z) = lb</p>
</blockquote>
<p>La formula sembra è contorta, l&#39;idea di base però è semplice, si cerca il massimo (o minimo) tra tutte le posssibili combinazioni dei bound dei due domini.</p>
<p>Filtrare su <em>x</em> è più complicato.</p>
<h2 id="bc-per-il-vincolo-del-valore-assoluto">BC per il vincolo del valore assoluto</h2>
<p>Filtering su <em>z</em></p>
<blockquote>
<p>z = |x|</p>
<p>ub = Max( |Max(x)|, |Min(x)| ) --&gt; Max(z) = ub</p>
<p>lb = |Max( Min(x), Min(0, Max(x)) )| --&gt; Min(z) = lb</p>
</blockquote>
<p>Filtering su <em>x</em></p>
<blockquote>
<p>z = |x|</p>
<p># Filter based on Max(z)</p>
<p>if Max(x) &gt; Max(z): Max(x) = Max(z)</p>
<p>if Min(x) &lt; -Max(z): Min(x) = -Max(z)</p>
<p># Filter based on Min(z)</p>
<p>if Min(x) ≥ 0: </p>
<p># x cannot be negative</p>
<p>  if Min(x) &lt; Min(z): Min(x) = Min(z)</p>
<p>if Max(z) &lt; 0: </p>
<p># x cannot be positive</p>
<p>  if Max(x) &gt; -Min(z): Max(x) = -Min(z)</p>
</blockquote>
<h2 id="bc-per-il-vincolo-del-minimo">BC per il vincolo del minimo</h2>
<p>Filtering su <em>z</em></p>
<blockquote>
<p>z = Min(x,y)</p>
<p>ub = Min(Max(x), Max(y)) --&gt; Max(z) = ub</p>
<p>lb = Min(Min(x), Min(y)) --&gt; Min(z) = lb</p>
</blockquote>
<p>Filtering su <em>x</em> (analogo per <em>y</em>)</p>
<blockquote>
<p>z = Min(x,y)</p>
<p>Max(x) &gt; Max(z), Min(y) &gt; Max(z) --&gt; Max(x) = Max(z)</p>
<p>Min(x) &lt; Min(z) --&gt; Min(x) = Min(z)</p>
</blockquote>
<h2 id="considerazioni-sul-bc-filtering">Considerazioni sul BC-filtering</h2>
<p>Con BC, tipicamente non si reisce a tagliare entrambi i domini, o si taglia quello di <em>z</em> o quello di <em>x</em> e <em>y</em>.</p>
<p>Pertanto la condizione minima per cui un algoritmo di filtering sia utile è che vada a fare il test di accettabilità dei buond dei domini.</p>
<h1 id="lezione-4-enumerazione-e-ottimizzazione">Lezione 4 - Enumerazione e Ottimizzazione</h1>
<p><em>Tra la lezione 3 e 4 ci sono stati due laboratiori.</em></p>
<h2 id="enumerazione-delle-soluzioni">Enumerazione delle soluzioni</h2>
<p>In alcuni casi, in CP può essere necessario trovare più soluzioni oppure sapere quante sono le possibili soluzioni.</p>
<p>Per risolvere questo problrma di enumerazione l&#39;algoritmo di ricerca DFS diventa:</p>
<pre><code class="lang-python">def <span class="hljs-function"><span class="hljs-title">DFS</span><span class="hljs-params">(CSP)</span></span>:
  <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-title">sol_found</span><span class="hljs-params">(CSP)</span></span>:
    process solution
    return
  <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-title">infeasible</span><span class="hljs-params">(CSP)</span></span>: return
  <span class="hljs-keyword">for</span> dec <span class="hljs-keyword">in</span> <span class="hljs-function"><span class="hljs-title">decisions</span><span class="hljs-params">(CSP)</span></span>:
      <span class="hljs-function"><span class="hljs-title">DFS</span><span class="hljs-params">(apply(dec, CSP)</span></span>)
</code></pre>
<p><code>or-tools</code> funziona in modo simile, ogni volta trova una soluzione si mette in pausa in modo da porterla utilizzare con il metodo <code>NextSolution()</code>.</p>
<h2 id="ottimizzazione-in-cp">Ottimizzazione in CP</h2>
<blockquote>
<p>COP = \&lt;X, D, C, f\&gt;</p>
</blockquote>
<p>È un CSP con una funzione (o espressione) obiettivo che deve essere minimizzata (si può ottenere una massimizzazione negando la funzione).</p>
<h3 id="optimal-map-coloring">Optimal Map Coloring</h3>
<p>Qual&#39;è il numero minimo di colori per colorare le regioni del nord Italia?</p>
<p>La definzione del modello è analoga a quella del relativo CSP, con la differenza che il dominio delle variabili va da <em>0</em> a <em>n-1</em>, dove <em>n</em> è il numero delle regioni.</p>
<p>Serve però una funzione obiettivo:</p>
<blockquote>
<p>f(x) = Max<sub>i = 0 ... n-1</sub>(x<sub>i</sub>)</p>
</blockquote>
<h2 id="risolizione-di-un-cop">Risolizione di un COP</h2>
<p>L&#39;idea principale è che risolvere un COP coincide con il risolvere una serie di CSP.</p>
<p>Ci sono vari approcci a questo tipo di problema, ma ci sono due filoni principali:</p>
<ul>
<li>Ricerca sul dominio di <em>f(x)</em></li>
<li>Branch &amp; Bound</li>
</ul>
<h3 id="rircerca">Rircerca</h3>
<h4 id="descructive-lower-bound">Descructive Lower Bound</h4>
<p>Si itera sui valori <em>v</em> del dominio di <em>f(x)</em> a partire dal lower bound, ad ogni iterazione si pone il vincolo <em>f(x) &lt;= v</em> e si risolve il CSP.</p>
<p>Probabilmente i primi CSP sono infiesible, però la prima soluzione che viene trovata risulta anche essere ottima.</p>
<p>Questo approccio viene chiamato <strong>descrutive</strong> perché ad ogni iterazione si butta via tutto quello calcolato per l&#39;iterazione precedentemente.</p>
<pre><code class="lang-python">sol = <span class="hljs-keyword">None</span> <span class="hljs-comment"># Current best solution</span>
solved = <span class="hljs-keyword">False</span> <span class="hljs-comment"># Outcome of the last solution attempt</span>
lb = safe lower bound
<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> solved:
  P = ⟨X,D,C ∪ {f(x) ≤ lb}⟩
  solved = solve(P)
  <span class="hljs-keyword">if</span> solved: sol = found solution
  <span class="hljs-keyword">else</span>: lb += <span class="hljs-number">1</span>
</code></pre>
<h4 id="destructive-upper-bound">Destructive Upper Bound</h4>
<p>Stesso ragionamento solo che si parte dal massimo valore di <em>f(x)</em>, è importante che il valore di partenza permetta di raggiungere una soluzione.</p>
<p>Ad ogni iterazione si usa <em>v = f(x) - 1</em>, cioè il costo della soluzione trovata al passo precedente <em>-1</em> in modo da provare a migliorare.</p>
<p>L&#39;ultima soluzione trovata è quella ottima.</p>
<p>Il vantaggio di questo algoritmo è che può essere interrotto ad ogni momento e fornisce comunque una soluzione anche se questa non è ottima.</p>
<p>Questo fatto è molto importante perché la maggior parte dei COP è NP-Difficile.</p>
<pre><code class="lang-python">sol = <span class="hljs-keyword">None</span> <span class="hljs-comment"># Current best solution</span>
solved = <span class="hljs-keyword">True</span> <span class="hljs-comment"># Outcome of the last solution attempt</span>
ub = safe upper bound
<span class="hljs-keyword">while</span> solved:
  P = ⟨X,D,C ∪ {f(x) ≤ ub}⟩
  solved = solve(P)
  <span class="hljs-keyword">if</span> solved:
    sol = found solution
    ub = sol(f(x)) - <span class="hljs-number">1</span>
</code></pre>
<h5 id="upper-vs-lower">Upper VS Lower</h5>
<p>La versione che usa il lower bound riesce a fare più propagazione risultando più efficiente anche se il problema che si va a risolvere probabilmente non ha soluzione e quindi bisogna esplorare tutto l&#39;albero.</p>
<p>Ovviamente la versione che usa il lower bound non è anytime però fornisce un lower bound che in alcuni casi può essere più interessante.</p>
<p>I passi del lower bound invece sono molto corti.</p>
<p>Per quanto riguarda la versione upper, questa funziona come duale del lower bound, i passi dell&#39;algoritmo sono più grandi, si trova a risolvere problemi per la maggior parte feasbile e quindi ci mette meno tempo.</p>
<p>Di contro non trova un lower bound e c&#39;è meno propagazione dei vincoli.</p>
<h3 id="binary-search">Binary Search</h3>
<p>È la combinazione dei due algoritmi, che va a fare una ricerca binaria sul dominio di <em>f(x)</em>.</p>
<p>L&#39;idea è quella di tenere un upper bound feasbile e un lower bound infeasible e di rivolvere il problema per <em>lb &lt; f(x) &lt; ub</em>.</p>
<p>Se si riesce a trovare una soluzione per quel problema si aggiorna <em>ub</em> con il valore di <em>f(x)</em>, altrimenti, se il problema è infeasible, si aggiorna <em>lb</em> con il valore di <em>f(x)</em>.</p>
<p>L&#39;algoritmo termina quanto viene trovata una soluzione <em>f(x) = lb+1</em>.</p>
<pre><code class="lang-python">sol = None #Current best solution
lb = safe lower bound
ub = safe upper bound
<span class="hljs-keyword">while</span> lb &lt; ub:
  P = ⟨X,<span class="hljs-keyword">D</span>,C ∪ {<span class="hljs-literal">f</span>(x) &gt; lb, <span class="hljs-literal">f</span>(x) &lt; ub}⟩
  solved = solve(P)
  <span class="hljs-keyword">if</span> solved:
    sol = found solution
    ub = sol(<span class="hljs-literal">f</span>(x))
  <span class="hljs-keyword">else</span>:
    lb = sol(<span class="hljs-literal">f</span>(x))
</code></pre>
<p>In questo modo si ottiene un algoritmo di tipo anytime che calcola anche un lower bound, che funziona a passi più grandi e che permette di effettuare una buona propagazione dal momento che ci sono vincoli sempre più stretti su <em>f(x)</em>.</p>
<p>Ma un altro grande vantaggio di questo approccio è l&#39;<strong>optimality gap</strong>, quando fermo l&#39;algoritmo prima della terminazione ottengo sia una soluzione per il problema CSP sia un indicatore della qualità della soluzione.</p>
<blockquote>
<p>og = (ub - lb) / lb</p>
</blockquote>
<h3 id="branch-and-bound">Branch and Bound</h3>
<p>Le ricerche hanno un problema: scartano la maggior parte delle informazioni ad ogni iterazione e questo porta a tanto lavoro ripetuto.</p>
<p>Nel B&amp;B, ogni volta che si trova una nuova soluzione si va ad aggiungere un nuovo vincolo di Bound sul valore di <em>f(x)</em>.</p>
<p>Utilizzando il branch and bound in CP non c&#39;è bisogno di calcolare per ogni nodo il lower bound, in quanto viene calcolato in modo automatico dai vincoli.</p>
<p>Quando l&#39;algoritmo trova una soluzione, per capire che è ottima deve comunque andare ad esplorare tutto l&#39;albero (<em>optimality proof</em>).</p>
<h4 id="pro-e-contro">Pro e contro</h4>
<ul>
<li>La prova di ottimalità può essere complessa, perché è necessario esplorare tutto l&#39;albero.</li>
<li>Non c&#39;è uno spreco di informazioni, l&#39;albero viene esplorato una volta sola.</li>
<li>È possibile fare passi grandi;</li>
<li>È un algoritmo anytime:</li>
<li>I lower bound ottenuti sono molto laschi.</li>
</ul>
<h2 id="reified-constraint">Reified Constraint</h2>
<p>Alcuni problemi possono essere complessi da modellare o possono essere modellati con modelli binari (tipo il problema del trasporto magazzino/cliente tipico della Ricerca Operativa).</p>
<p>Implementare un CSP come modello binario ha dei problemi in quanto ci sono molte variabili e non si può fare tanta propoagazione.</p>
<h1 id="lezione-5-metavincoli">Lezione 5 - Metavincoli</h1>
<p>Non si riesce a modellare in modo efficace il problema dei trasporti, serve quindi una nuova tipologia di vincoli</p>
<h2 id="vincoli-come-espressioni">Vincoli come espressioni</h2>
<blockquote>
<p>z = (x<sub>i</sub> == j)</p>
<p>z = 1 se x<sub>i</sub> = j</p>
<p>z = 0 altrimenti</p>
</blockquote>
<p>In partica <em>z</em> diventa una &quot;variabile&quot; che vale <em>1</em> se il vincolo è soddisfatto e <em>0</em> nel caso non lo sia, un concetto simile alle variabili binarie della programmazione lineare.</p>
<p>Si dice che il vincolo <em>z</em> è un vincolo <strong>reificato</strong> (reified constraing), cioè un espressione che corrisponde allo stato di soddisfacibilità di un vincolo.</p>
<p>Un <strong>meta-vincolo</strong> è quindi un vincolo definito utilizzando dei vincoli reificati.</p>
<p>Questa tipologia di vincoli sono molto utili per modellare un problema, tuttavia:</p>
<ul>
<li>Portano ad avere dei modelli complicati;</li>
<li>Portano ad avere dei modelli grandi, quindi serve più tempo per fare filtering;</li>
<li>Portano ad avere un filtering debole.</li>
</ul>
<h3 id="gac-per-i-vincoli-reificati">GAC per i vincoli reificati</h3>
<p>Il dominio di un vincolo reificato è sempre {0,1}, il valore 1 ha supporto se e solo se c&#39;è la possibilità che il vincolo sia soddisfatto e lo stesso vale per il valore 0.</p>
<p>Si parla di <em>dominio di un vincolo</em> perché i vincoli reificati possono essere visti come delle variabili.</p>
<p>Se un vincolo reificato <strong>non</strong> è soddisfatto <strong>non</strong> vuol dire che il problema è infeasible, questo perché un vincolo reificato non è un vincolo del problema originale, ma è un modo di collegare lo stato di un vincolo ad una variabile.</p>
<h3 id="filtering-per-i-vincoli-reificati">Filtering per i vincoli reificati</h3>
<p>Se <em>(c)</em> è il vincolo reificato per il vincolo <em>c</em>, prima è necessario filtrare per il vincolo <em>c</em>.</p>
<p>Se si ottiene un domain wipeout allora <em>D(c)</em> non contiene 1 e se <em>c</em> è risoloto, allora <em>D(c)</em> non contiene 0.</p>
<h2 id="vincoli-logici">Vincoli logici</h2>
<p>Servono per risolvere i problemi di soddifacibilità booleana (<strong>SAT</strong>) nei quali bisogna determinare se una clausola booleana è soddisfacibile.</p>
<p>Non serve andare ad aggiungere dei nuovi vincoli, si possono andare a riciclare alcuni vincoli già noti.</p>
<blockquote>
<p>z = not x</p>
<p>z = (1 - x)</p>
</blockquote>
<p>Se <em>z</em> e <em>x</em> sono variabili binarie le due esperessioni sono equivalenti.</p>
<p>In questo modo si possono riutilizzare le regole di filtering che vengono usate per le espressioni già note.</p>
<p>Allo stesso modo</p>
<blockquote>
<p>z = x ∧ y</p>
<p>z = x * y oppure z = min(x,y)</p>
<p>z = x ∨ y</p>
<p>z = max(x,y)</p>
</blockquote>
<p>Non serve quindi andare ad implementare i vincoli logici in quanto è possibile riutilizzare quelli aritmetici, in questo modo si può riutilizzare anche il filtering e il GAC.</p>
<p>Avendo un modo per mappare i vincoli logici basilari si possono anche andare a definire quelli più complessi come il ⇒ e ⇔, tuttavia la cosa diventa più verbosa.</p>
<blockquote>
<p>x⇔y </p>
<p>diventa </p>
<p>max(xy,(1−x)(1−y)) </p>
</blockquote>
<p>Ma si può fare di meglio:</p>
<blockquote>
<p>z = (x ⇒ y)</p>
<p>z = (x ≤ y) //Con un vincolo reificato</p>
<p>z = (x⇔y)</p>
<p>z = (x==y)</p>
<p>z = (x ⊕ y) (xor)</p>
<p>z = (x != y)</p>
</blockquote>
<h2 id="wombo-combo">Wombo combo</h2>
<p>Utilizzando i metavincoli e i vincolo logici è possibile andare a definire dei vincoli più complessi come: <em>Se x allora y</em>.</p>
<p>Permettendo così di modellare tutte le relazioni combinatorie su variabili discrete.</p>
<p>Tuttavia questa non sempre è una buona idea perché così facendo si ottiene un modello grande e il filtering debole.</p>
<p>Questo perché i metavincoli potrebbero non esse GAC anche se tutti i vincoli individuali sono GAC.</p>
<h2 id="riprendiamo-la-ricerca">Riprendiamo la ricerca</h2>
<p>L&#39;algoritmo finora utilizzato è il seguente:</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span><span class="hljs-params">(CSP)</span>:</span>
    <span class="hljs-keyword">if</span> sol_found(CSP): <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
    <span class="hljs-keyword">if</span> infeasible(CSP): <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
    <span class="hljs-keyword">for</span> dec <span class="hljs-keyword">in</span> decisions(CSP):
        <span class="hljs-keyword">if</span> DFS(apply(dec, CSP)): <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre>
<ul>
<li>Prende la prima variabile x<sub>i</sub> che non è ancora bound</li>
<li>Si prende il valore minimo <em>v</em></li>
<li>Si prendono due decisioni:<ul>
<li><em>x<sub>i</sub> = v</em> (branch sinistro)</li>
<li><em>x<sub>i</sub> != v</em> (se faccio backtracking)</li>
</ul>
</li>
</ul>
<p>Si può andare a migliorare cambiando la <strong>variable selection heuristic</strong>, cioè cambiare come si sceglie la variabile e <strong>value selection heuristic</strong>, cioè come scegliere il valore per fare il branching.</p>
<p>L&#39;idea è quella di scegliere l&#39;euristica migliore che permette di risolvere il problema.</p>
<p>Questa euristica risulta essere specifica per alcuni tipi di problemi, perché non è possibile trovare un euristica per risolvere un problema generico.</p>
<p>Nei problemi in cui si cerca solamente una soluzione, l&#39;idea è quella di scegliere sia la variabile che il valore in modo che ci sia una maggior probabilità di arrivare ad una soluzione feasible.</p>
<p>Tuttavia questa strategia non limita il <strong>trashing</strong>, se si prende una decisione sbagliata e si genera tutto un sotto-albero infeasible è necessario esaminare tutto il sotto-albero prima di accorgersene.</p>
<p>Sarebbe bello avere un modo di limitare questo fenomeno.</p>
<p>Se le variabili hanno domini diversi, queste influenzano la struttura dell&#39;albero di ricerca.</p>
<p>In genere scegliendo come variabile alla quale assegnare un valore, la variabile che ha il dominio più piccolo, si ottengono due grandi vantaggi:</p>
<ul>
<li>La propagazione è più forte;</li>
<li>È molto più probabile che si faccia propagazione.</li>
</ul>
<p>Si cerca quindi di massimizzare la propagazione scegliendo variabili a valori che cercano di causare un fail (<strong>first fail principle</strong>).</p>
<p>Quindi ricapitolando:</p>
<ul>
<li>Se si crede che il problema sia feasible, si cerca di assegnare il valore che è più facile che porti ad una soluzione;</li>
<li>Se si crede che il problema sia infeasible, si cerca di fallire il prima possibile.</li>
</ul>
<p>Di solito non si sa se il problema è feasible o infeasible, quindi si sceglie la variabile con il dominio più piccolo (si cerca il fail) e il valore che aumenta la probabilità di successo (varia da problema a problema).</p>
<h1 id="lezione-6-ricerca-2">Lezione 6 - Ricerca 2</h1>
<p><em>Nelle precedenti puntate:</em> scegli una variabile in modo che sia più probabile fallire e scegli un valore in modo che si più probabile trovare una soluzione.</p>
<h2 id="ricerca-per-i-problemi-di-ottimizzazione">Ricerca per i problemi di ottimizzazione</h2>
<p>Oltre a trovare la solzuone è necessario provare che sia ottima, è necessario qundi andare ad esplorare tutto l&#39;albero.</p>
<p>Tipicamente si scelgono sia variabili che valori con la qualità più alta possibile, cioè che portino ad ottenere dei vincoli più stretti.</p>
<p>Questo perché i vincoli più stretti fanno un pruning maggiore e velocizzano il processo di ricerca.</p>
<p>Il tutto deriva dal fatto che facendo il B&amp;B ogni volta che si trova una nuova soluzione si ottiene un nuovo vincolo.</p>
<h2 id="alternative-branching-scheme">Alternative Branching Scheme</h2>
<p>Finora abbiamo fatto branching con un ramo <em>x=v</em> e uno <em>x!=v</em>, possono però essere usate strategia diverse, come:</p>
<ul>
<li><strong>labeling</strong>: tanti rami quanti sono i possibili valori della variabile;</li>
<li><strong>paritioning</strong>: <em>x &lt;= v</em> e <em>x&gt;v</em>, è utile quando si rappresentano qunatità o si hanno domini larghi.</li>
<li><strong>probing/diving</strong>: non faccio branching, assegno la variabile ad un valore, questo è utile quando non è necessario fare backtracking (<em>violazione di DFS</em>).</li>
</ul>
<h2 id="su-cosa-fare-branching">Su cosa fare branching</h2>
<p>In alcuni casi, come quando si lavora con intervalli di tempo, la scelta della variabile sulla quale fare branching influisce di molto sulle prestazioni.</p>
<p>Ad esempio è possibile assegnare il valore dei vincoli reificati a delle variabili ed utilizzare queste nuove variabili per fare branching.</p>
<p>In questo modo viene fatta della propagazione dei vincoli già nella fase di ricerca.</p>
<p>Rimane solo da assegnare un valore alle variabili. Questi valori possono essere assegnati facendo probing, utilizzando il minor start time possibile per ogni variabile.</p>
<p>Ottenendo così una soluzione ottima in poco tempo.</p>
<h2 id="ricapitolando">Ricapitolando</h2>
<ul>
<li>La ricerca in CP è molto flessibile (selezione delle variabili, schema di branching e variabili da usare per fare branching)</li>
<li>CP può essere utilizzato per implementare delle euristiche</li>
<li>Per ottenere i risultati migliori è necessario modificare l&#39;algoritmo</li>
</ul>
<h1 id="lezione-7-migliorare-un-modello">Lezione 7 - Migliorare un modello</h1>
<p>Lo stesso problema può essere modellato in modi diversi, alcuni sono più semplici da modellare rispetto ad altri e allo stesso modo alcuni sono più efficenti di altri.</p>
<p>Inoltre. anche gli stessi vincoli possono influire sulle prestazioni, così come la scelta dei valori &quot;farlocchi&quot; va ad influire sulle prestazioni.</p>
<p>Ad esempio: se nel problema di pianificazione della produzione di una macchina, scelgo il valore <em>-1</em> per rappresentare un ciclo di pausa della macchina posso ottenere delle prestazioni peggiori rispetto al modello che usa <em>eoh</em> o un altro valore per modellare tale ciclo.
Questo dipende da come vengono scegli dal risolutore i valori da assegnare alle variabili.</p>
<p>Un altro problema è dato dalle simmetrie nelle soluzioni, che possono portare ad creare branch di ricerca inutili, pertanto può essere utile aggiungere dei vincoli per andarle a rimuovere.</p>
<p>Ad esempio, se devo produrre in serie 5 unità x<sub>1</sub> ... x<sub>5</sub> dello stesso prodotto, le due soluzioni [x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>, x<sub>4</sub>, x<sub>5</sub>] e [x<sub>4</sub>, x<sub>2</sub>, x<sub>1</sub>, x<sub>3</sub>, x<sub>5</sub>] sono equivalenti, pertanto convine aggiungere dei vincoli che rimuovono queste soluzioni simmetriche.</p>
<p>Allo stesso modo, quando si tratta di allocare delle quantità di qualche materiale in dei contenitori identici, è possibili vincolare l&#39;assegnamento <em>x<sub>1</sub> = 0</em>, dal momento che la prima sostanza può essere messa indiscriminatamente in ognuno dei contenitori e ciò porta ad avere delle soluzioni simmetriche.</p>
<h2 id="simmetrie">Simmetrie</h2>
<p>Possono essere sia di variabile che di valore.</p>
<p>Quelle di <strong>variabile</strong> si verificano quando, data una soluzione feasible è possibile scambiare i valori delle variabili ed ottenere comunque un&#39;altra soluzione feasible.</p>
<p>In quelle di <strong>valore</strong> invece si va a permutare i vari valori (ridare il nome ai valori), ad esempio in N-Queens c&#39;è una simmetria di valori se si fa una rotazione orizzontale della scacchiera.</p>
<p>Per rompere queste simmetrie è possibile:</p>
<ul>
<li>Riformulare il modello in modo da togliere o diminuire le simmetrie</li>
<li><strong>Simmetry Breaking statico</strong> vengono aggiunti dei vincoli al modello per rompere le simmetrie</li>
<li><strong>Simmetry Breaking dinamico</strong></li>
</ul>
<h3 id="lex-leader-method-statico-">Lex-Leader Method (statico)</h3>
<p>È una strategia per rompere le simmetrie di variabile in modo statico.</p>
<p>L&#39;idea è quella di imporre un ordine lessicografico tra le varie variabili in modo che ci sia solo una delle soluzioni simmetriche valide.</p>
<p>Deve però essere disponibile la lista di tutte le possibili permutazioni.</p>
<p>Di contro però vengono aggiunti dei vincolo grandi e il numero di vincoli da aggiungere cresce in modo <strong>fattoriale</strong> rispetto al numero di simmetrie.</p>
<p><strong>Caso speciale</strong>: se c&#39;è un vincolo che impone che le varie variabili siano tutte diverse tra loro allora è necessario aggiungere <em>n-1</em> vincoli, anziché <em>n!</em>.</p>
<h3 id="rottura-delle-simmetrie-dinamica">Rottura delle simmetrie dinamica</h3>
<p>Il metodo statico porta ad aggiungere tanti vincoli e questi possono creare dei problemi alla strategia di ricerca, perché questi vincoli potrebbero andare a tagliare delle soluzioni simmetriche che sono trovate per prime dalla strategia di ricerca.</p>
<p>L&#39;idea principale di questa strategia è quella di considerare i vincoli che rompono le simmetrie solo quando si fa backtracking.
In questo modo quando si scende sul ramo sinistro non vengono tagliate le soluzioni simmetriche, ma quando si fa backtracking, questi vengono considerati in modo da sfoltire il sotto albero destro.</p>
<p>Ad esempio facendo labeling fermandosi al primo valore simmetrico trovato.</p>
</body></html>